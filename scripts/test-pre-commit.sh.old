#!/bin/bash
# LMB pre-commit hook
# Build: hooks-20260125.001
# Doel: Header afdwingen/normaliseren + Build-datum check (alleen feature/* en hotfix/*)

set -euo pipefail


echo "HIER BEN IK"
sleep 5

BRANCH="$(git rev-parse --abbrev-ref HEAD)"

# Alleen afdwingen op feature/* en hotfix/*
if ! [[ "$BRANCH" =~ ^feature/ || "$BRANCH" =~ ^hotfix/ ]]; then
  exit 0
fi

echo "[LMB pre-commit] Header + buildcontrole (branch: $BRANCH)"

# Repo/projectnaam (kan je overriden met LMB_PROJECT_NAME)
TOPLEVEL="$(git rev-parse --show-toplevel)"
REPO_NAME="$(basename "$TOPLEVEL")"
PROJECT_NAME="${LMB_PROJECT_NAME:-$REPO_NAME}"

# Build-standaard (prefix) - default dev
BUILD_PREFIX="${LMB_BUILD_PREFIX:-dev}"

TODAY="$(date +%Y%m%d)"

# Welke bestanden wil je afdwingen?
# (pas aan naar jouw repo; hieronder behoud ik je eerdere lijst)
FILES=(
  "testassets/js/global.js"
  "assets/js/components/Wishlist.js"
)

changed_any=0
changed_files=()

escape_sed_repl() {
  # escape \ & / voor sed replacement
  printf '%s' "$1" | sed -e 's/[\/&]/\\&/g' -e 's/\\/\\\\/g'
}

ensure_header_and_build() {
  local file="$1"
  local component="$2"
  local default_first_release="$3"

  local target_build="${BUILD_PREFIX}-${TODAY}.000"

  # 1) Bepaal huidige Build uit header (alleen in de eerste ~80 regels zoeken)
  local build_line=""
  build_line="$(head -n 80 "$file" | grep -m1 -E '^[[:space:]]*\*[[:space:]]*Build:[[:space:]]*' || true)"

  local current_build=""
  if [[ -n "$build_line" ]]; then
    current_build="$(printf '%s' "$build_line" | sed -E 's/^[[:space:]]*\*[[:space:]]*Build:[[:space:]]*//')"
  fi

  # 2) Valideer buildformat + check datum
  #    Verwacht: <prefix>-YYYYMMDD.NNN
  #    - Als invalid of verkeerde dag: zet naar prefix-TODAY.000
  local needs_build_update=0
  if [[ -z "$current_build" ]]; then
    needs_build_update=1
  else
    if [[ "$current_build" =~ ^${BUILD_PREFIX}-([0-9]{8})\.([0-9]{3})$ ]]; then
      local build_date="${BASH_REMATCH[1]}"
      if [[ "$build_date" != "$TODAY" ]]; then
        needs_build_update=1
      fi
    else
      needs_build_update=1
    fi
  fi

  # 3) Check of er een headerblock bestaat bovenaan
  #    We accepteren een header als het bestand begint met /* binnen de eerste non-empty chars
  local first_nonempty=""
  first_nonempty="$(grep -n -m1 -E '[^[:space:]]' "$file" | cut -d: -f1 || true)"
  if [[ -z "$first_nonempty" ]]; then
    # leeg bestand: maak minimaal header + laat rest leeg
    cat > "$file" <<EOF
/* Project: $PROJECT_NAME
 * Component: $component
 * Build: $target_build
 * First Release: $default_first_release
 * Last Change: -
 * Source: New
 * 
 * Purpose:
 * 
 */
EOF
    return 0
  fi

  local starts_with_block=0
  local first_line=""
  first_line="$(sed -n "${first_nonempty}p" "$file")"
  if [[ "$first_line" =~ ^[[:space:]]*/\* ]]; then
    starts_with_block=1
  fi

  # 4) Functie: update/insert key line binnen bestaand headerblock (alleen in eerste block comment)
  #    We manipuleren alleen het eerste /* ... */ blok.
  local tmp
  tmp="$(mktemp)"

  if [[ "$starts_with_block" -eq 0 ]]; then
    # Geen headerblock: voeg toe bovenaan
    cat > "$tmp" <<EOF
/* Project: $PROJECT_NAME
 * Component: $component
 * Build: $target_build
 * First Release: $default_first_release
 * Last Change: -
 * Source: New
 * 
 * Purpose:
 * 
 */
EOF
    cat "$file" >> "$tmp"
    mv "$tmp" "$file"
    return 0
  fi

  # 5) Bestaand headerblock: we lezen t/m het einde van eerste */ en vullen/normaliseren keys.
  #    Strategie:
  #    - Verzamel headerblock (van eerste /* t/m eerste */)
  #    - Check/ensure keys:
  #      Project, Component, Build, First Release, Last Change, Source, Purpose
  #    - Update Project/Component altijd
  #    - Update Build als needs_build_update=1
  #    - Voeg ontbrekende keys toe vóór "Purpose:" (of aan het einde van header als Purpose ontbreekt)
  #    - Purpose laten we inhoudelijk leeg/zoals het is, maar key moet bestaan

  awk -v project="$PROJECT_NAME" \
      -v component="$component" \
      -v target_build="$target_build" \
      -v default_first_release="$default_first_release" \
      -v update_build="$needs_build_update" '
  BEGIN {
    in_header=0; header_done=0;
    hasProject=0; hasComponent=0; hasBuild=0; hasFirst=0; hasLast=0; hasSource=0; hasPurpose=0;
  }
  function norm_key(line,   s) {
    s=line;
    sub(/^[[:space:]]*\*[[:space:]]*/, "", s);
    return s;
  }
  function emit_missing_before_purpose() {
    if (!hasProject)   print " * Project: " project;
    if (!hasComponent) print " * Component: " component;
    if (!hasBuild)     print " * Build: " target_build;
    if (!hasFirst)     print " * First Release: " default_first_release;
    if (!hasLast)      print " * Last Change: -";
    if (!hasSource)    print " * Source: New";
    print " * ";
  }
  {
    if (!header_done) {
      if (!in_header) {
        # Start headerblock?
        if ($0 ~ /^[[:space:]]*\/\*/) {
          in_header=1;
          print $0;
          next;
        } else {
          # niet in header; print gewoon
          print $0;
          next;
        }
      } else {
        # In headerblock
        # Einde header?
        if ($0 ~ /\*\//) {
          # Als Purpose nooit gezien is, voeg missing keys + Purpose toe
          if (!hasPurpose) {
            emit_missing_before_purpose();
            print " * Purpose:";
            print " * ";
